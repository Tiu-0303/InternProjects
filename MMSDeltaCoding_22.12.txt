import os
import re
import threading
from datetime import datetime
import pandas as pd
import customtkinter as ctk
from tkinter import filedialog, messagebox
import subprocess
import sys


# ======================================================
# PYINSTALLER SAFE RESOURCE PATH
# ======================================================
def resource_path(relative_path: str) -> str:
    """
    Works for:
    - normal python run (dev)
    - PyInstaller onefile/onedir (uses sys._MEIPASS)
    """
    base_path = getattr(sys, "_MEIPASS", os.path.abspath("."))
    return os.path.join(base_path, relative_path)


# ======================================================
# EXTRACTION CONFIG (MMS DELTA)
# ======================================================
TARGET_COLS = ["X", "Y", "Z", "R", "T", "Gap_X", "Gap_Y"]

TARGET_PATTERNS = {
    "X": r"^X$",
    "Y": r"^Y$",
    "Z": r"^Z(\d+)?$",  # Z, Z1, Z2...
    "R": r"^R$",
    "T": r"^T$",
    "Gap_X": r"^Gap[_\s-]?X$",
    "Gap_Y": r"^Gap[_\s-]?Y$",
}

Z_PREFERENCE = ["Z", "Z1", "Z2", "Z3", "Z4"]


# ======================================================
# HELPERS
# ======================================================
def normalize_text(x):
    if x is None or (isinstance(x, float) and pd.isna(x)):
        return ""
    s = str(x).strip()
    s = s.replace("-", "_")
    s = re.sub(r"\s+", "_", s)
    return s


def normalize_label(lbl):
    """
    SAFE: only strip suffix if it is exactly '-LED<number>'
    e.g. U1_LED10-LED8 -> U1_LED10
    """
    if lbl is None or (isinstance(lbl, float) and pd.isna(lbl)):
        return ""
    s = str(lbl).strip()
    if re.search(r"-LED\d+$", s, flags=re.IGNORECASE):
        s = re.sub(r"-LED\d+$", "", s, flags=re.IGNORECASE)
    return s


def detect_target(measure_value):
    m = normalize_text(measure_value)
    for target, pattern in TARGET_PATTERNS.items():
        if re.fullmatch(pattern, m, flags=re.IGNORECASE):
            return target, m
    return None, m


def z_rank(m):
    m = str(m).upper()
    pref = [z.upper() for z in Z_PREFERENCE]
    if m in pref:
        return pref.index(m)
    mm = re.match(r"^Z(\d+)$", m)
    if mm:
        return 100 + int(mm.group(1))
    return 500


def read_csv_safely(path):
    try:
        return pd.read_csv(path, sep=None, engine="python", encoding="utf-8", on_bad_lines="skip")
    except UnicodeDecodeError:
        return pd.read_csv(path, sep=None, engine="python", encoding="cp1252", on_bad_lines="skip")


def list_data_files_recursive(folder):
    """Recursive scan: includes all subfolders."""
    files = []
    for root, _, filenames in os.walk(folder):
        for f in filenames:
            if f.startswith("~$"):
                continue
            lf = f.lower()
            if lf.endswith((".csv", ".xlsx", ".xlsm", ".xls")):
                files.append(os.path.join(root, f))
    return sorted(files)


def open_folder(path: str):
    path_abs = os.path.abspath(path)
    if sys.platform == "win32":
        subprocess.Popen(["explorer", path_abs])
    elif sys.platform == "darwin":
        subprocess.Popen(["open", path_abs])
    else:
        subprocess.Popen(["xdg-open", path_abs])


def show_file(path: str):
    path_abs = os.path.abspath(path)
    if sys.platform == "win32":
        subprocess.Popen(["explorer", "/select,", path_abs])
    elif sys.platform == "darwin":
        subprocess.Popen(["open", "-R", path_abs])
    else:
        open_folder(os.path.dirname(path_abs))


# ======================================================
# EXTRACTION CORE (DELTA)
# ======================================================
def extract_from_df(df):
    if not {"LABEL", "Measure", "Delta"}.issubset(df.columns):
        return None

    rows = []
    for _, r in df.iterrows():
        target, norm = detect_target(r.get("Measure"))
        if not target:
            continue
        rows.append({
            "LABEL": normalize_label(r.get("LABEL")),
            "Target": target,
            "Measure_norm": norm,
            "Value": r.get("Delta"),  # âœ… DELTA
        })

    if not rows:
        return None

    sub = pd.DataFrame(rows)

    # Choose best Z per LABEL if multiple (Z, Z1, Z2...)
    is_z = sub["Target"].eq("Z")
    if is_z.any():
        sub["Z_rank"] = 999
        sub.loc[is_z, "Z_rank"] = sub.loc[is_z, "Measure_norm"].apply(z_rank)

        z_best = (
            sub[is_z]
            .sort_values(["LABEL", "Z_rank"])
            .drop_duplicates(["LABEL", "Target"], keep="first")
        )
        sub = pd.concat([sub[~is_z], z_best], ignore_index=True)

    pivot = sub.pivot_table(
        index="LABEL",
        columns="Target",
        values="Value",
        aggfunc="last"
    ).reset_index()

    for c in TARGET_COLS:
        if c not in pivot.columns:
            pivot[c] = None

    return pivot[["LABEL"] + TARGET_COLS]


def extract_file(path):
    ext = os.path.splitext(path)[1].lower()

    if ext == ".csv":
        df = read_csv_safely(path).dropna(how="all")
        return extract_from_df(df)

    try:
        xls = pd.ExcelFile(path)
    except Exception:
        return None

    parts = []
    for s in xls.sheet_names:
        try:
            df = pd.read_excel(xls, sheet_name=s).dropna(how="all")
            p = extract_from_df(df)
            if p is not None and not p.empty:
                parts.append(p)
        except Exception:
            pass

    return pd.concat(parts, ignore_index=True) if parts else None


def run_paths(paths, out_folder, progress_cb, status_cb):
    outputs = []
    total = len(paths)

    for i, p in enumerate(paths, 1):
        status_cb(f"Processing {i}/{total}: {os.path.basename(p)}")
        df = extract_file(p)
        if df is not None and not df.empty:
            outputs.append(df)
        progress_cb(i, total)

    if not outputs:
        raise RuntimeError("No valid Delta data found in selected input.")

    final_df = pd.concat(outputs, ignore_index=True)

    # remove LABEL in output (still used internally for grouping)
    final_df = final_df.drop(columns=["LABEL"], errors="ignore")

    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    out_path = os.path.join(out_folder, f"Extracted_Delta_{ts}.xlsx")
    final_df.to_excel(out_path, index=False, sheet_name="MMS Data")
    return out_path


# ======================================================
# UI (CUSTOMTKINTER - MATCH XRAY STYLE)
# ======================================================
class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("MMS Data Extractor")
        self.geometry("750x450")
        self.minsize(720, 430)
        ctk.set_appearance_mode("System")

        # titlebar icon (optional; taskbar icon comes from PyInstaller --icon)
        try:
            self.iconbitmap(resource_path("mms.ico"))
        except Exception:
            pass

        self.selected_path = ctk.StringVar(value="No input selected")
        self.status = ctk.StringVar(value="Ready")
        self.last_output = None
        self.input_kind = None  # "folder" or "file"

        main = ctk.CTkFrame(self, corner_radius=10)
        main.pack(fill="both", expand=True, padx=20, pady=20)

        ctk.CTkLabel(
            main,
            text="MMS Data Extractor",
            font=ctk.CTkFont(size=26, weight="bold")
        ).pack(anchor="w", padx=20, pady=(20, 0))

        ctk.CTkLabel(
            main,
            text="Extract Delta values for X / Y / Z / R / T / Gap_X / Gap_Y (recursive supported)",
            font=ctk.CTkFont(size=13)
        ).pack(anchor="w", padx=20, pady=(6, 0))

        input_frame = ctk.CTkFrame(main, corner_radius=10)
        input_frame.pack(fill="x", padx=20, pady=20)
        input_frame.grid_columnconfigure((0, 1, 2, 3), weight=1)

        ctk.CTkLabel(
            input_frame,
            textvariable=self.selected_path,
            fg_color=("#E5E7E9", "#2C2C2C"),
            corner_radius=6,
            anchor="w",
            justify="left"
        ).grid(row=0, column=0, columnspan=4, sticky="ew", padx=15, pady=15)

        ctk.CTkButton(
            input_frame, text="Select Folder", command=self.pick_folder,
            fg_color="#3498DB", hover_color="#2E86C1"
        ).grid(row=1, column=0, padx=(15, 5), pady=10, sticky="ew")

        ctk.CTkButton(
            input_frame, text="Select File", command=self.pick_file,
            fg_color="#3498DB", hover_color="#2E86C1"
        ).grid(row=1, column=1, padx=5, pady=10, sticky="ew")

        self.btn_start = ctk.CTkButton(
            input_frame, text="Start Extraction", command=self.start,
            state="disabled", fg_color="#2ECC71", hover_color="#27AE60",
            font=ctk.CTkFont(weight="bold")
        )
        self.btn_start.grid(row=1, column=2, padx=5, pady=10, sticky="ew")

        ctk.CTkButton(
            input_frame, text="Clear", command=self.clear,
            fg_color="#E74C3C", hover_color="#C0392B",
            font=ctk.CTkFont(weight="bold")
        ).grid(row=1, column=3, padx=(5, 15), pady=10, sticky="ew")

        self.pb = ctk.CTkProgressBar(main)
        self.pb.pack(fill="x", padx=20, pady=(10, 0))
        self.pb.set(0)

        ctk.CTkLabel(main, textvariable=self.status).pack(anchor="w", padx=20, pady=10)

        action = ctk.CTkFrame(main)
        action.pack(fill="x", padx=20, pady=10)

        self.btn_open_folder = ctk.CTkButton(
            action, text="Open Output Folder", command=self.open_out_folder,
            state="disabled", fg_color="#95A5A6", hover_color="#7F8C8D"
        )
        self.btn_open_folder.pack(side="left", expand=True, padx=5)

        self.btn_open_file = ctk.CTkButton(
            action, text="Show Output File", command=self.open_out_file,
            state="disabled", fg_color="#95A5A6", hover_color="#7F8C8D"
        )
        self.btn_open_file.pack(side="left", expand=True, padx=5)

    def pick_folder(self):
        p = filedialog.askdirectory(title="Select folder (recursive scan)")
        if p:
            self.selected_path.set(p)
            self.input_kind = "folder"
            self.btn_start.configure(state="normal")
            self.status.set("Folder selected (recursive scan). Ready.")

    def pick_file(self):
        p = filedialog.askopenfilename(
            title="Select file",
            filetypes=[("Data files", "*.csv *.xlsx *.xlsm *.xls"), ("All files", "*.*")]
        )
        if p:
            self.selected_path.set(p)
            self.input_kind = "file"
            self.btn_start.configure(state="normal")
            self.status.set("File selected. Ready.")

    def clear(self):
        self.selected_path.set("No input selected")
        self.status.set("Ready")
        self.pb.set(0)
        self.input_kind = None
        self.last_output = None
        self.btn_start.configure(state="disabled")
        self.btn_open_folder.configure(state="disabled")
        self.btn_open_file.configure(state="disabled")

    def start(self):
        path = self.selected_path.get()
        if not path or path == "No input selected":
            messagebox.showerror("Error", "Please select a folder or file first.")
            return

        if self.input_kind == "folder":
            if not os.path.isdir(path):
                messagebox.showerror("Error", "Invalid folder.")
                return
            paths = list_data_files_recursive(path)
            if not paths:
                messagebox.showerror("Error", "No supported files found in the selected folder (including subfolders).")
                return
            out_folder = path
        elif self.input_kind == "file":
            if not os.path.isfile(path):
                messagebox.showerror("Error", "Invalid file.")
                return
            paths = [path]
            out_folder = os.path.dirname(path)
        else:
            messagebox.showerror("Error", "Please select a folder or file first.")
            return

        self.btn_start.configure(state="disabled")
        self.btn_open_folder.configure(state="disabled")
        self.btn_open_file.configure(state="disabled")
        self.pb.set(0)
        self.status.set(f"Found {len(paths)} file(s). Running...")

        def progress(done, total):
            val = (done / total) if total else 1.0
            self.after(0, lambda: self.pb.set(val))

        def status_cb(msg):
            self.after(0, lambda: self.status.set(msg))

        def worker():
            try:
                out = run_paths(paths, out_folder, progress, status_cb)
                self.last_output = out
                self.after(0, lambda: self.btn_open_folder.configure(state="normal"))
                self.after(0, lambda: self.btn_open_file.configure(state="normal"))
                self.after(0, lambda: self.status.set(f"Done: {os.path.basename(out)}"))
                self.after(0, lambda: messagebox.showinfo("Done", f"Saved:\n{out}"))
            except Exception as e:
                self.after(0, lambda: messagebox.showerror("Error", str(e)))
                self.after(0, lambda: self.status.set(f"Failed: {e}"))
            finally:
                self.after(0, lambda: self.btn_start.configure(state="normal"))

        threading.Thread(target=worker, daemon=True).start()

    def open_out_folder(self):
        if self.last_output and os.path.exists(self.last_output):
            open_folder(os.path.dirname(self.last_output))
        else:
            messagebox.showinfo("Info", "No output yet. Run extraction first.")

    def open_out_file(self):
        if self.last_output and os.path.exists(self.last_output):
            show_file(self.last_output)
        else:
            messagebox.showinfo("Info", "No output yet. Run extraction first.")


if __name__ == "__main__":
    App().mainloop()
